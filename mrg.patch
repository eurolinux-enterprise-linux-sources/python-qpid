From 5ee6c709f29b3d85e461955ba6e268e7b946db5a Mon Sep 17 00:00:00 2001
From: Michael Goulish <mgoulish@apache.org>
Date: Fri, 27 Jan 2012 16:18:01 +0000
Subject: [PATCH 1/8] Bug 752381, QPID-3778: md5 connection abort fix for
 previous fix. This one doesn't break  
 qpid.tests.connection.ConnectionTest.testCloseGet   and
   qpid.tests.connection.ConnectionTest.testCloseListen

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@1236729 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/connection.py |   10 ++++++++--
 1 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/connection.py b/qpid/python/qpid/connection.py
index 7dbefb8..f2c83d1 100644
--- a/qpid/python/qpid/connection.py
+++ b/qpid/python/qpid/connection.py
@@ -27,6 +27,7 @@ from generator import control_invoker
 from exceptions import *
 from logging import getLogger
 import delegates, socket
+import sys
 
 class ChannelBusy(Exception): pass
 
@@ -159,11 +160,16 @@ class Connection(Framer):
     while not self.closed:
       try:
         data = self.sock.recv(64*1024)
-        if self.security_layer_rx and data:
-          status, data = self.security_layer_rx.decode(data)
         if not data:
           self.detach_all()
           break
+        # If we have a security layer and it sends us no decoded data,
+        # that's OK as long as its return code is happy.
+        if self.security_layer_rx:
+          status, data = self.security_layer_rx.decode(data)
+          if not status:
+            self.detach_all()
+            break
       except socket.timeout:
         if self.aborted():
           self.close_code = (None, "connection timed out")
-- 
1.7.7.6

From cf0d55b61010cb270ce78aeef4ebad2213a11ca3 Mon Sep 17 00:00:00 2001
From: Michael Goulish <mgoulish@apache.org>
Date: Wed, 14 Mar 2012 14:33:28 +0000
Subject: [PATCH 2/8] Bug 790563, QPID-3898: Python client is disconnected
 from the broker shortly after connection over ssl

When connecting through SSL, qpid-tool starts disconnecting and
reconnecting every 10 seconds.

The connection it makes is good -- it gets real data.  But then
it unilaterally decides to disconnect, immediately reconnects --
and cycles this way forever.   Well -- until you stop it, anyway.
qpid-stat does not do this.

This is similar to a problem that was fixed long ago in the original
code -- but that was written  before SSL support was available in Python.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@1300562 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/connection.py |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/qpid/python/qpid/connection.py b/qpid/python/qpid/connection.py
index f2c83d1..66e1cb4 100644
--- a/qpid/python/qpid/connection.py
+++ b/qpid/python/qpid/connection.py
@@ -170,6 +170,10 @@ class Connection(Framer):
           if not status:
             self.detach_all()
             break
+      # When we do not use SSL transport, we get periodic 
+      # spurious timeout events on the socket.  When using SSL,
+      # these events show up as timeout *errors*.  Both should be
+      # ignored unless we have aborted.
       except socket.timeout:
         if self.aborted():
           self.close_code = (None, "connection timed out")
@@ -178,9 +182,12 @@ class Connection(Framer):
         else:
           continue
       except socket.error, e:
-        self.close_code = (None, str(e))
-        self.detach_all()
-        break
+        if self.aborted() or str(e) != "The read operation timed out":
+          self.close_code = (None, str(e))
+          self.detach_all()
+          break
+        else:
+          continue
       frame_dec.write(data)
       seg_dec.write(*frame_dec.read())
       op_dec.write(*seg_dec.read())
-- 
1.7.7.6

From 8c15f0a6761023d9ce20c1c4cb533150d3c980bf Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 11 Apr 2012 12:03:58 +0000
Subject: [PATCH 3/8] Bug 693444, QPID-3943: Make topic subscriptions
 unreliable by default

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@1324719 13f79535-47bb-0310-9956-ffa450edef68

Conflicts:

	qpid/tests/src/py/qpid_tests/broker_0_10/new_api.py
---
 qpid/python/qpid/messaging/driver.py |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 23efeaa..8c6af25 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -226,7 +226,11 @@ class LinkIn:
 
   def do_link(self, sst, rcv, _rcv, type, subtype, action):
     link_opts = _rcv.options.get("link", {})
-    reliability = link_opts.get("reliability", "at-least-once")
+    if type == "topic":
+      default_reliability = "unreliable"
+    else:
+      default_reliability = "at-least-once"
+    reliability = link_opts.get("reliability", default_reliability)
     declare = link_opts.get("x-declare", {})
     subscribe = link_opts.get("x-subscribe", {})
     acq_mode = acquire_mode.pre_acquired
-- 
1.7.7.6

From 5d2a079ad895168eeafa30058a3c9df44c931dda Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Thu, 26 Jul 2012 15:42:23 -0400
Subject: [PATCH 4/8] Bug 841488 - qpid-stat does not support multi-byte
 characters (UTF-8)

---
 qpid/python/qpid/disp.py |   12 +++++++++---
 1 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/qpid/python/qpid/disp.py b/qpid/python/qpid/disp.py
index c29ea00..b8dc31f 100644
--- a/qpid/python/qpid/disp.py
+++ b/qpid/python/qpid/disp.py
@@ -139,7 +139,10 @@ class Display:
     for head in heads:
       width = len (head)
       for row in rows:
-        cellWidth = len (unicode (row[col]))
+        text = row[col]
+        if text.__class__ == str:
+          text = text.decode('utf-8')
+        cellWidth = len(unicode(text))
         if cellWidth > width:
           width = cellWidth
       colWidth.append (width + self.tableSpacing)
@@ -159,9 +162,12 @@ class Display:
       line = self.tablePrefix
       col  = 0
       for width in colWidth:
-        line = line + unicode (row[col])
+        text = row[col]
+        if text.__class__ == str:
+          text = text.decode('utf-8')
+        line = line + unicode(text)
         if col < len (heads) - 1:
-          for i in range (width - len (unicode (row[col]))):
+          for i in range (width - len(unicode(text))):
             line = line + " "
         col = col + 1
       print line
-- 
1.7.7.6

From 1dcbcc4e2ea7e71138f2a8e5a9c714b2c9c14650 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Fri, 27 Jul 2012 11:46:57 -0400
Subject: [PATCH 5/8] Bug 825078 - qpid-tools no longer works with SSL

---
 qpid/python/qpid/connection.py          |    5 +-
 qpid/python/qpid/delegates.py           |   73 ++++++++++++------------------
 qpid/python/qpid/framer.py              |   14 +++---
 qpid/python/qpid/messaging/endpoints.py |   12 +++++
 qpid/python/qpid/sasl.py                |    5 ++
 qpid/python/qpid/util.py                |    4 +-
 6 files changed, 59 insertions(+), 54 deletions(-)

diff --git a/qpid/python/qpid/connection.py b/qpid/python/qpid/connection.py
index 66e1cb4..2453f38 100644
--- a/qpid/python/qpid/connection.py
+++ b/qpid/python/qpid/connection.py
@@ -166,8 +166,9 @@ class Connection(Framer):
         # If we have a security layer and it sends us no decoded data,
         # that's OK as long as its return code is happy.
         if self.security_layer_rx:
-          status, data = self.security_layer_rx.decode(data)
-          if not status:
+          try:
+            data = self.security_layer_rx.decode(data)
+          except:
             self.detach_all()
             break
       # When we do not use SSL transport, we get periodic 
diff --git a/qpid/python/qpid/delegates.py b/qpid/python/qpid/delegates.py
index 8dbdc37..5e44a3a 100644
--- a/qpid/python/qpid/delegates.py
+++ b/qpid/python/qpid/delegates.py
@@ -24,13 +24,7 @@ from exceptions import VersionError, Closed
 from logging import getLogger
 from ops import Control
 import sys
-
-_have_sasl = None
-try:
-  import saslwrapper
-  _have_sasl = True
-except:
-  pass
+from qpid import sasl
 
 log = getLogger("qpid.io.ctl")
 
@@ -159,7 +153,8 @@ class Client(Delegate):
   def __init__(self, connection, username=None, password=None,
                mechanism=None, heartbeat=None, **kwargs):
     Delegate.__init__(self, connection)
-
+    self.client_properties=Client.PROPERTIES.copy()
+    self.client_properties.update(kwargs.get("client_properties",{}))
     ##
     ## self.acceptableMechanisms is the list of SASL mechanisms that the client is willing to
     ## use.  If it's None, then any mechanism is acceptable.
@@ -171,20 +166,19 @@ class Client(Delegate):
     self.username  = username
     self.password  = password
 
-    if _have_sasl:
-      self.sasl = saslwrapper.Client()
-      if username and len(username) > 0:
-        self.sasl.setAttr("username", str(username))
-      if password and len(password) > 0:
-        self.sasl.setAttr("password", str(password))
-      self.sasl.setAttr("service", str(kwargs.get("service", "qpidd")))
-      if "host" in kwargs:
-        self.sasl.setAttr("host", str(kwargs["host"]))
-      if "min_ssf" in kwargs:
-        self.sasl.setAttr("minssf", kwargs["min_ssf"])
-      if "max_ssf" in kwargs:
-        self.sasl.setAttr("maxssf", kwargs["max_ssf"])
-      self.sasl.init()
+    self.sasl = sasl.Client()
+    if username and len(username) > 0:
+      self.sasl.setAttr("username", str(username))
+    if password and len(password) > 0:
+      self.sasl.setAttr("password", str(password))
+    self.sasl.setAttr("service", str(kwargs.get("service", "qpidd")))
+    if "host" in kwargs:
+      self.sasl.setAttr("host", str(kwargs["host"]))
+    if "min_ssf" in kwargs:
+      self.sasl.setAttr("minssf", kwargs["min_ssf"])
+    if "max_ssf" in kwargs:
+      self.sasl.setAttr("maxssf", kwargs["max_ssf"])
+    self.sasl.init()
 
   def start(self):
     # XXX
@@ -203,38 +197,29 @@ class Client(Delegate):
         mech_list += str(mech) + " "
     mech = None
     initial = None
-    if _have_sasl:
-      status, mech, initial = self.sasl.start(mech_list)
-      if status == False:
-        raise Closed("SASL error: %s" % self.sasl.getError())
-    else:
-      if self.username and self.password and ("PLAIN" in mech_list):
-        mech = "PLAIN"
-        initial = "\0%s\0%s" % (self.username, self.password)
-      else:
-        mech = "ANONYMOUS"
-        if not mech in mech_list:
-          raise Closed("No acceptable SASL authentication mechanism available")
-    ch.connection_start_ok(client_properties=Client.PROPERTIES, mechanism=mech, response=initial)
+    try:
+      mech, initial = self.sasl.start(mech_list)
+    except Exception, e:
+      raise Closed(str(e))
+    ch.connection_start_ok(client_properties=self.client_properties,
+                           mechanism=mech, response=initial)
 
   def connection_secure(self, ch, secure):
     resp = None
-    if _have_sasl:
-      status, resp = self.sasl.step(secure.challenge)
-      if status == False:
-        raise Closed("SASL error: %s" % self.sasl.getError())
+    try:
+      resp = self.sasl.step(secure.challenge)
+    except Exception, e:
+      raise Closed(str(e))
     ch.connection_secure_ok(response=resp)
 
   def connection_tune(self, ch, tune):
     ch.connection_tune_ok(heartbeat=self.heartbeat)
     ch.connection_open()
-    if _have_sasl:
-      self.connection.user_id = self.sasl.getUserId()
-      self.connection.security_layer_tx = self.sasl
+    self.connection.user_id = self.sasl.auth_username()
+    self.connection.security_layer_tx = self.sasl
 
   def connection_open_ok(self, ch, open_ok):
-    if _have_sasl:
-      self.connection.security_layer_rx = self.sasl
+    self.connection.security_layer_rx = self.sasl
     self.connection.opened = True
     notify(self.connection.condition)
 
diff --git a/qpid/python/qpid/framer.py b/qpid/python/qpid/framer.py
index 47f57cf..8e4ef01 100644
--- a/qpid/python/qpid/framer.py
+++ b/qpid/python/qpid/framer.py
@@ -51,9 +51,10 @@ class Framer(Packer):
     self.sock_lock.acquire()
     try:
       if self.security_layer_tx:
-        status, cipher_buf = self.security_layer_tx.encode(self.tx_buf)
-        if status == False:
-          raise Closed(self.security_layer_tx.getError())
+        try:
+          cipher_buf = self.security_layer_tx.encode(self.tx_buf)
+        except SASLError, e:
+          raise Closed(str(e))
         self._write(cipher_buf)
       else:
         self._write(self.tx_buf)
@@ -91,9 +92,10 @@ class Framer(Packer):
       try:
         s = self.sock.recv(n) # NOTE: instead of "n", arg should be "self.maxbufsize"
         if self.security_layer_rx:
-          status, s = self.security_layer_rx.decode(s)
-          if status == False:
-            raise Closed(self.security_layer_tx.getError())
+          try:
+            s = self.security_layer_rx.decode(s)
+          except SASLError, e:
+            raise Closed(str(e))
       except socket.timeout:
         if self.aborted():
           raise Closed()
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 338ac70..e632c0c 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -116,6 +116,13 @@ class Connection(Endpoint):
     @type address_ttl: float
     @param address_ttl: time until cached address resolution expires
 
+    @type ssl_keyfile: str
+    @param ssl_keyfile: file with client's private key (PEM format)
+    @type ssl_certfile: str
+    @param ssl_certfile: file with client's public (eventually priv+pub) key (PEM format)
+    @type ssl_trustfile: str
+    @param ssl_trustfile: file trusted certificates to validate the server
+
     @rtype: Connection
     @return: a disconnected Connection
     """
@@ -160,6 +167,11 @@ class Connection(Endpoint):
     self.address_ttl = options.get("address_ttl", 60)
     self.tcp_nodelay = options.get("tcp_nodelay", False)
 
+    self.ssl_keyfile = options.get("ssl_keyfile", None)
+    self.ssl_certfile = options.get("ssl_certfile", None)
+    self.ssl_trustfile = options.get("ssl_trustfile", None)
+    self.client_properties = options.get("client_properties", {})
+
     self.options = options
 
 
diff --git a/qpid/python/qpid/sasl.py b/qpid/python/qpid/sasl.py
index fed6dea..25de6de 100644
--- a/qpid/python/qpid/sasl.py
+++ b/qpid/python/qpid/sasl.py
@@ -29,6 +29,9 @@ class WrapperClient:
 
   def setAttr(self, name, value):
     status = self._cli.setAttr(str(name), str(value))
+    if status and name == 'username':
+      status = self._cli.setAttr('externaluser', str(value))
+      
     if not status:
       raise SASLError(self._cli.getError())
 
@@ -89,6 +92,8 @@ class PlainClient:
       return "PLAIN", "\0%s\0%s" % (self.attrs.get("username"), self.attrs.get("password"))
     elif "ANONYMOUS" in mechs:
       return "ANONYMOUS", "%s@%s" % (self.attrs.get("username"), socket.gethostname())
+    elif "EXTERNAL" in mechs:
+      return "EXTERNAL", "%s" % (self.attrs.get("username"))
     else:
       raise SASLError("sasl negotiation failed: no mechanism agreed")
 
diff --git a/qpid/python/qpid/util.py b/qpid/python/qpid/util.py
index 8967728..7541595 100644
--- a/qpid/python/qpid/util.py
+++ b/qpid/python/qpid/util.py
@@ -25,9 +25,9 @@ except ImportError:
   from socket import ssl as wrap_socket
   class ssl:
 
-    def __init__(self, sock):
+    def __init__(self, sock, keyfile=None, certfile=None, trustfile=None):
       self.sock = sock
-      self.ssl = wrap_socket(sock)
+      self.ssl = wrap_socket(sock, keyfile=keyfile, certfile=certfile, ca_certs=trustfile)
 
     def recv(self, n):
       return self.ssl.read(n)
-- 
1.7.7.6

From 28dba58b058450dc38ae9662cecd1043260b588e Mon Sep 17 00:00:00 2001
From: "Rafael H. Schloming" <rhs@apache.org>
Date: Mon, 30 Jul 2012 23:03:46 +0000
Subject: [PATCH 6/8] Bug 841196, QPID-4147: made selector handle interrupt
 based on patch from siddesh

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@1367354 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/selector.py                  |   24 ++++++++++++++++++------
 qpid/python/qpid/tests/messaging/endpoints.py |   12 ++++++++++++
 2 files changed, 30 insertions(+), 6 deletions(-)

diff --git a/qpid/python/qpid/selector.py b/qpid/python/qpid/selector.py
index ca5946c..ff94091 100644
--- a/qpid/python/qpid/selector.py
+++ b/qpid/python/qpid/selector.py
@@ -16,7 +16,7 @@
 # specific language governing permissions and limitations
 # under the License.
 #
-import atexit, time
+import atexit, time, errno
 from compat import select, set, selectable_waiter
 from threading import Thread, Lock
 
@@ -111,12 +111,24 @@ class Selector:
           else:
             wakeup = min(wakeup, t)
 
-      if wakeup is None:
-        timeout = None
-      else:
-        timeout = max(0, wakeup - time.time())
+      rd = []
+      wr = []
+      ex = []
 
-      rd, wr, ex = select(self.reading, self.writing, (), timeout)
+      while True:
+        try:
+          if wakeup is None:
+            timeout = None
+          else:
+            timeout = max(0, wakeup - time.time())
+          rd, wr, ex = select(self.reading, self.writing, (), timeout)
+          break
+        except Exception, (err, strerror):
+          # Repeat the select call if we were interrupted.
+          if err == errno.EINTR:
+            continue
+          else:
+            raise
 
       for sel in wr:
         if sel.writing():
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index db5ec03..975c4a3 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -1333,3 +1333,15 @@ class SenderTests(Base):
     self.drain(self.rcv, expected=msgs)
     self.ssn.acknowledge()
     assert caught, "did not exceed capacity"
+
+  def testEINTR(self):
+    m1 = self.content("testEINTR", 0)
+    m2 = self.content("testEINTR", 1)
+
+    self.snd.send(m1, timeout=self.timeout())
+    try:
+      os.setuid(500)
+      assert False, "setuid should fail"
+    except:
+      pass
+    self.snd.send(m2, timeout=self.timeout())
-- 
1.7.7.6

From 7f6d1755951cb2a4ebe31c5f5c6a4623e575e1db Mon Sep 17 00:00:00 2001
From: Kenneth Giusti <kgiusti@redhat.com>
Date: Thu, 16 Aug 2012 14:31:02 -0400
Subject: [PATCH 7/8] Bug 825078 - qpid-tools no longer works with SSL

---
 qpid/python/qpid/util.py |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/util.py b/qpid/python/qpid/util.py
index 7541595..fe66e9b 100644
--- a/qpid/python/qpid/util.py
+++ b/qpid/python/qpid/util.py
@@ -26,6 +26,9 @@ except ImportError:
   class ssl:
 
     def __init__(self, sock, keyfile=None, certfile=None, trustfile=None):
+      if keyfile or certfile:
+        # BZ825078 - client authentication with old API not yet tested
+        raise Exception("Client authentication not supported by this version.")
       self.sock = sock
       self.ssl = wrap_socket(sock, keyfile=keyfile, certfile=certfile, ca_certs=trustfile)
 
-- 
1.7.7.6

From e2687b3b045f5b2f02249b3beacb8b712b05d807 Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Thu, 16 Aug 2012 17:59:51 +0000
Subject: [PATCH 8/8] Bug 825078 - qpid-tools no longer works with SSL
 NO-JIRA: remove unsupported argument.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@1373957 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a2eb4becc8e99524415183fe05ea407c87ff3798)
---
 qpid/python/qpid/util.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/util.py b/qpid/python/qpid/util.py
index fe66e9b..bbac4e2 100644
--- a/qpid/python/qpid/util.py
+++ b/qpid/python/qpid/util.py
@@ -30,7 +30,7 @@ except ImportError:
         # BZ825078 - client authentication with old API not yet tested
         raise Exception("Client authentication not supported by this version.")
       self.sock = sock
-      self.ssl = wrap_socket(sock, keyfile=keyfile, certfile=certfile, ca_certs=trustfile)
+      self.ssl = wrap_socket(sock, keyfile=keyfile, certfile=certfile)
 
     def recv(self, n):
       return self.ssl.read(n)
-- 
1.7.7.6

