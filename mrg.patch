diff --git a/qpid/python/qpid/connection.py b/qpid/python/qpid/connection.py
index 7dbefb8..66e1cb4 100644
--- a/qpid/python/qpid/connection.py
+++ b/qpid/python/qpid/connection.py
@@ -27,6 +27,7 @@ from generator import control_invoker
 from exceptions import *
 from logging import getLogger
 import delegates, socket
+import sys
 
 class ChannelBusy(Exception): pass
 
@@ -159,11 +160,20 @@ class Connection(Framer):
     while not self.closed:
       try:
         data = self.sock.recv(64*1024)
-        if self.security_layer_rx and data:
-          status, data = self.security_layer_rx.decode(data)
         if not data:
           self.detach_all()
           break
+        # If we have a security layer and it sends us no decoded data,
+        # that's OK as long as its return code is happy.
+        if self.security_layer_rx:
+          status, data = self.security_layer_rx.decode(data)
+          if not status:
+            self.detach_all()
+            break
+      # When we do not use SSL transport, we get periodic 
+      # spurious timeout events on the socket.  When using SSL,
+      # these events show up as timeout *errors*.  Both should be
+      # ignored unless we have aborted.
       except socket.timeout:
         if self.aborted():
           self.close_code = (None, "connection timed out")
@@ -172,9 +182,12 @@ class Connection(Framer):
         else:
           continue
       except socket.error, e:
-        self.close_code = (None, str(e))
-        self.detach_all()
-        break
+        if self.aborted() or str(e) != "The read operation timed out":
+          self.close_code = (None, str(e))
+          self.detach_all()
+          break
+        else:
+          continue
       frame_dec.write(data)
       seg_dec.write(*frame_dec.read())
       op_dec.write(*seg_dec.read())
